version: "3.8"

services:
  # MinIO - Stockage objet S3-like
  minio:
    image: minio/minio:latest
    container_name: minio
    ports:
      - "9002:9000"   # API S3 depuis l'hôte: http://localhost:9002
      - "9001:9001"   # Console web MinIO: http://localhost:9001
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
    volumes:
      - minio_data:/data
    command: server /data --console-address ":9001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3

  # MinIO Client pour initialisation (création des buckets/policies)
  mc:
    image: minio/mc:latest
    container_name: mc
    depends_on:
      - minio
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
    volumes:
      - ./scripts:/scripts
    entrypoint: ["/bin/sh", "-c"]   # ✅ forcer un shell (sinon 'command' est passé à 'mc')
    command: |
      set -e
      # Attente que MinIO soit prêt
      for i in $(seq 1 30); do
        mc alias set myminio http://minio:9000 "$MINIO_ROOT_USER" "$MINIO_ROOT_PASSWORD" && break
        echo "MinIO pas prêt, retry ($i/30)..." && sleep 2
      done

      # Buckets (idempotent)
      mc mb myminio/datalake-bronze || true
      mc mb myminio/datalake-silver || true
      mc mb myminio/datalake-gold   || true

      # Politiques (selon version mc, 'policy set public' ou 'anonymous set download')
      mc policy set public myminio/datalake-bronze  || mc anonymous set download myminio/datalake-bronze  || true
      mc policy set public myminio/datalake-silver  || mc anonymous set download myminio/datalake-silver  || true
      mc policy set public myminio/datalake-gold    || mc anonymous set download myminio/datalake-gold    || true

      echo "Buckets créés avec succès!"
      # Garder le conteneur vivant pour pouvoir faire 'docker compose exec mc ...'
      tail -f /dev/null

  # Service ETL Python
  etl:
    build:
      context: .
      dockerfile: Dockerfile.etl
    container_name: etl
    depends_on:
      - minio
      - mc
    environment:
      MINIO_ENDPOINT: minio:9000     # depuis les conteneurs, on vise le service Docker
      MINIO_ACCESS_KEY: ${MINIO_ROOT_USER}
      MINIO_SECRET_KEY: ${MINIO_ROOT_PASSWORD}
      MINIO_SECURE: "false"
    volumes:
      - ./src:/app/src
      - ./data:/app/data
      - ./scripts:/app/scripts
    working_dir: /app
    command: tail -f /dev/null  # garde le container en vie

  # JupyterLab Notebook
  notebook:
    build:
      context: .
      dockerfile: Dockerfile.notebook
    container_name: notebook
    ports:
      - "8888:8888"
    depends_on:
      - minio
    environment:
      MINIO_ENDPOINT: minio:9000
      MINIO_ACCESS_KEY: ${MINIO_ROOT_USER}
      MINIO_SECRET_KEY: ${MINIO_ROOT_PASSWORD}
      MINIO_SECURE: "false"
    volumes:
      - ./src:/app/src
      - ./data:/app/data
      - ./notebooks:/app/notebooks
      - ./scripts:/app/scripts
    working_dir: /app
    command: jupyter lab --ip=0.0.0.0 --port=8888 --no-browser --allow-root --NotebookApp.token='' --NotebookApp.password=''

  # Dashboard Streamlit
  dashboard:
    build:
      context: .
      dockerfile: Dockerfile.dashboard
    container_name: dashboard
    ports:
      - "8501:8501"
    depends_on:
      - minio
    environment:
      MINIO_ENDPOINT: minio:9000
      MINIO_ACCESS_KEY: ${MINIO_ROOT_USER}
      MINIO_SECRET_KEY: ${MINIO_ROOT_PASSWORD}
      MINIO_SECURE: "false"
    volumes:
      - ./src:/app/src
      - ./data:/app/data
      - ./scripts:/app/scripts
    working_dir: /app
    command: streamlit run src/visualization/dashboard.py --server.port=8501 --server.address=0.0.0.0

volumes:
  minio_data:
